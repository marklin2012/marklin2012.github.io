<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="来自⎡凹凸实验室⎦iOSer的Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="MarkLin's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MarkLin's Blog">
<meta property="og:description" content="来自⎡凹凸实验室⎦iOSer的Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MarkLin's Blog">
<meta name="twitter:description" content="来自⎡凹凸实验室⎦iOSer的Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> MarkLin's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MarkLin's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/02/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-02T14:29:50+08:00" content="2016-03-02">
              2016-03-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/02/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/02/hello-world/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/20/CoreData/" itemprop="url">
                  我的第一个Core Data APP -- Swift
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-20T11:43:59+08:00" content="2015-01-20">
              2015-01-20
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/01/20/CoreData/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/01/20/CoreData/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在这个教程中，你会看到在Xcode提供的初始化代码模板和数据模型编辑器资源中，用Swift语言写出你的第一个Core Data app，将会是一件多么容易上手的事情</p>
<ul>
<li>使用Xcode的模型编辑器在Core Data中创建你想存储的模型数据</li>
<li>在Core Data中添加一条新记录</li>
<li>从Core Data中获取一组记录</li>
<li>在列表视图中显示用户的数据</li>
</ul>
<p>你还可以看到一个Core Data在在后台是如何与各组件进行交互的。我们正在超越自我，但-是时候简历一个应用程序了！</p>
<p>本文翻译自 <a href="http://www.raywenderlich.com/85578/first-core-data-app-using-swift" target="_blank" rel="external">http://www.raywenderlich.com/85578/first-core-data-app-using-swift</a></p>
<p><strong><em>Ray的说明</em></strong>:本文是<a href="http://www.raywenderlich.com/store/swift-tutorials-bundle" target="_blank" rel="external">Core Data by Tutorials</a>一书中<a href="http://www.raywenderlich.com/82230/introducing-ios-8-feast" target="_blank" rel="external">iOS8 Feast</a>部分章节的微缩版本，让你了解一下这是一本什么样的书。我们希望你喜欢！</p>
<h3 id="开始教程"><a href="#开始教程" class="headerlink" title="开始教程"></a>开始教程</h3><p>打开Xcode，然后选择 <strong><em>Single View Application</em></strong> 模板，创建一个新的iPhone工程，将其命名为 <strong><em>HitList</em></strong>，并勾选 <strong><em>Use Core data</em></strong>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-8ace73e118eb0cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p1"></p>
<p>检查看看Xcode的 <strong><em>Use Core data</em></strong> 框架 <code>AppDelegate.swift</code>中自动生成了 <strong><em>Core data stack</em></strong> 样板代码。</p>
<p>Core Data 堆栈是由一组便于保存和检索信息的对象所组成。还有一个目的是管理Core Data状态作为一个表示数据模型等等的整体。</p>
<hr>
<p><strong><em>Note</em></strong>：不是所有的Xcode模板都可以选择 <strong><em>Use Core data</em></strong> 的选项。在Xcode 6中，只有 <strong><em>Master-Detail Application</em></strong> 和 <strong><em>Single View Application</em></strong> 两个模板可以有该选项。</p>
<hr>
<p>本文例子中得app非常简单。就是会有一个命名为“hit list”的列表视图，你能够将名称添加到列表中，你将使用Core Data来保证数据存储。在本教程中，我们不会以任何暴力形式强迫你，你可以认为这个app是个“favorites list”,用于记录你的好友，这当然没有问题！</p>
<p>点击进入<code>Main.storyboard</code>在Interface Builder中打开。选择View Controller 然后改变他的常规高度和宽度匹配iPhone的纵向模式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-c0245facc8be2ef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p2"></p>
<p>接着，嵌入一个导航控制器到视图控制器中。从Xcode的 <strong><em>Editor</em></strong> 菜单，选择 <strong><em>Embed In…\ Navigation Controller</em></strong> 。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-c6822d2c1d1d130c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p3"></p>
<p>回到Interface Builder，从对象库的标示图中拖拽一个<code>Table View</code>出来，并覆盖整个视图。</p>
<p>然后再拖拽一个<code>Bar Button Item</code>放置到新增加的视图控制器的导航栏上。最后，双击<code>Bar Button Item</code>将文本设置为 <strong><em>Add</em></strong> 。你的画布应该像下面的截图那样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-4903167e702b815a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p4"></p>
<p>每次你点击顶端右侧的<code>Add</code>时，将会在屏幕上出现一个包含文本框的警告，你可以在里面输入某人的名字到文本框中。退去警告将保存名字并刷新列表视图显示所有你保存过的名字。</p>
<p>在你完成这些功能之前，你需要连接视图控制器和列表视图的数据源。按住Ctrl拖拽列表视图到导航栏上方黄色的视图控制器图标，如下图所示，然后点击<code>dataSource</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-31c0a886d164cb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p5"></p>
<p>你可能会疑惑为什么不需要设置列表视图的代理，这是因为点击cell并不会触发任何的事件。没有比这更简单的了！</p>
<p>通过按下 Command-Option-Enter 或者选择Xcode工具条目上的中间按钮，打开辅助编辑器。按住Ctrl拖拽<br>列表视图到<code>ViewController.swift</code>，在类定义中插入outlet：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-80e9d9a416c8c853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p6"></p>
<p>取名为tableView，如下行所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@IBOutlet weak var tableView: UITableView!</span><br></pre></td></tr></table></figure>
<p>按住Ctrl拖拽<code>Add</code>按钮到<code>ViewController.swift</code>，同时创建一个action代替outlet生成一个方法名为<code>addName</code>的事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func addName(sender: AnyObject)&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以参考下表格视图和按钮条目的action代码。接着，设置标示图的模型，在<code>ViewController.swift</code>中添加如下属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Insert below the tableView IBOutlet</span><br><span class="line">var names = [String]()</span><br></pre></td></tr></table></figure>
<p><code>names</code>是一个可变的数组，用来保存显示列表视图上的字符。</p>
<p>将<code>viewDidLoad</code>的实现替换成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  	super.viewDidLoad()</span><br><span class="line">  	title = &quot;\&quot;The List\&quot;&quot;</span><br><span class="line">  	tableView.registerClass(UITableViewCell.self,</span><br><span class="line">    forCellReuseIdentifier: &quot;Cell&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将在列表视图中注册一个<code>UITableViewCell</code>的类，你这样做将会使你再队列cell的时候，让列表视图返回一个正确类型的cell。</p>
<p>还是在<code>ViewController.swift</code>, <code>ViewController</code>将通过编辑类声明来确认遵守<code>UITableViewDataSource</code>协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Add UITableViewDataSource to class declaration</span><br><span class="line">class ViewController: UIViewController, UITableViewDataSource &#123;</span><br></pre></td></tr></table></figure>
<p>此时，Xcode将报错关于viewController没有遵守协议。</p>
<p>在<code>viewDidLoad</code>下面实现如下数据源方法来解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// MARK: UITableViewDataSource</span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">    numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    return names.count</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  cellForRowAtIndexPath</span><br><span class="line">  indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line"> </span><br><span class="line">    let cell =</span><br><span class="line">        tableView.dequeueReusableCellWithIdentifier(&quot;Cell&quot;)</span><br><span class="line">        as UITableViewCell</span><br><span class="line"> </span><br><span class="line">    cell.textLabel!.text = names[indexPath.row]</span><br><span class="line"> </span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用过<code>UITableView</code>,这些代码将会看起来很熟悉。第一个方法是说明列表视图的行数和<code>names</code>数组的字符串个数一样多。</p>
<p>第二个方法<code>tableView(_:cellForRowAtIndexPath:)</code>,队列他们的列表视图cell并按照<code>names</code>中字符串填充.</p>
<p>先不要运行app。你还需要输入字符串好让列表视图来显示他们。</p>
<p>实现你之前拖拽的代码<code>addName IBAction</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Implement the addName IBAction</span><br><span class="line">@IBAction func addName(sender: AnyObject) &#123;</span><br><span class="line"> </span><br><span class="line">  var alert = UIAlertController(title: &quot;New name&quot;,</span><br><span class="line">      message: &quot;Add a new name&quot;,</span><br><span class="line">      preferredStyle: .Alert)</span><br><span class="line"> </span><br><span class="line">  let saveAction = UIAlertAction(title: &quot;Save&quot;,</span><br><span class="line">   style: .Default) &#123; (action: UIAlertAction!) -&gt; Void in</span><br><span class="line"> </span><br><span class="line">    let textField = alert.textFields![0] as UITextField</span><br><span class="line">    self.names.append(textField.text)</span><br><span class="line">    self.tableView.reloadData()</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  let cancelAction = UIAlertAction(title: &quot;Cancel&quot;,</span><br><span class="line">    style: .Default) &#123; (action: UIAlertAction!) -&gt; Void in</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  alert.addTextFieldWithConfigurationHandler &#123;</span><br><span class="line">    (textField: UITextField!) -&gt; Void in</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  alert.addAction(saveAction)</span><br><span class="line">  alert.addAction(cancelAction)</span><br><span class="line"> </span><br><span class="line">  presentViewController(alert,</span><br><span class="line">      animated: true,</span><br><span class="line">      completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当你点击<code>Add</code>按钮时，该方法将会弹出一个带有文本框和两个按钮<code>Save</code>和<code>Cancel</code>的<code>UIAlertController</code>。<br>点击<code>Save</code>将会插入你当前文本框上的内容到<code>names</code>数组中，并且会刷新列表视图。由于names数组是支持列表视图的模型，所以无论你输入什么到文本框中，都会在列表视图上展示。</p>
<p>最后，该第一次运行你的程序了，点击<code>Add</code>按钮，警告控制器就会像这个样子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-53fd182ac30197df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p7"></p>
<p>添加4到5个名称到列表中。你应该会获得如下样式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-1181c13dc1915577.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p8"></p>
<p>你的列表视图会展示你保存名称的数组中的数据，但这里最大的问题是缺少持续性。这个数组只是存在内存中，如果你强退或者重启你的设备，你的名单将会消失。</p>
<p>Core Data提供了持续性，这意味着他能以一个更持久的状态存储数据，使他能在app重启或者设备重启之后还存在。</p>
<p>你还没有添加Core Data， 所以在你退出app后没有什么可以保存下来。让我们试一下看看。如果你用的是真机调试，按住Home建，或者在你的模拟器中按下 Shift+Command+H，这样将会让你回到熟悉的网格主页。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-5cd523a3daad0bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p9"></p>
<p>从主页上点击<code>HitList</code>图标，重新回到app的前台。名称还是留在屏幕上，怎么回事？</p>
<p>但你点击Home键时，app从前台进入到后台。这时，操作系统会暂时冻结你内存上的所有内容，包括你的names数组。同样地道理，当你唤醒app返回到前台，操作系统将恢复到之前的状态，就像你没有离开过一样。</p>
<p>Apple 在iOS4之后引入了多线程， 他们为用户创建了一个无缝的体验，但这为开发者的持久性数据带来了来疑惑。这些名称真的是持久的吗？</p>
<p>不，这并不是持久的。如果你在程序快速切换页面完全杀死app或者关掉你的手机，那些名称将会消失。你当然可以去验证他。在程序运行的前台，双击Home键进入程序快速切换页面，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-516ed0c6eeb114b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p10"></p>
<p>从这里，向上滑出HitList的快照来终止应用程序。这应该不会存在一丝HitList的内存（这里没有双关语）。返回到主页点击HitList的图标重新启动app，验证名称是否消失。</p>
<p>如果你开发过iOS或者熟悉多线程编程的方法，内存暂存和持久性的区别显而易见。但在用户的眼里，他们并不关心名称是否还存在内存中，他们不关心app是进入后台，然后回来，或者app是否被保存，并重新加载。</p>
<p>他们在意的是当他们返回的时候，名称是否还在。</p>
<p>所以，在本教程中你即将学会的是你一个让你在重新启动app时依然保存有之前数据的持久化教程。</p>
<h3 id="为你的数据创建模型"><a href="#为你的数据创建模型" class="headerlink" title="为你的数据创建模型"></a>为你的数据创建模型</h3><p>现在你知道改如何验证数据的持久性了，那就让我们开始Core Data吧！HitList的目标非常简单：持久化你输入的名称，使它们在你重新启动app后，依然可见。</p>
<p>到现在为止，你已经实现用Swift字符串在内存中储存名称。在这个章节，你将用Core Data对象替换这些字符串。</p>
<p>第一步，先创建一个阐述在磁盘上表示Core Data的<code>managed object model</code>。默认情况下，Core Data 使用SQLite数据库进行持久化存储，所以你可以认为数据模型就是数据库架构。</p>
<hr>
<p><code>Note</code>: 你会在这个教程中遇到颇多<code>managed</code>单词。如果你再类名中见到<code>managed</code>这个单词，比如<code>NSManagedObjectContrxt</code>，说明你再处理一个Core Data的类。<code>Managed</code>表示Core Data对象生命周期的Core Data数据管理。</p>
<p>但是不要以为所有的Core Data类都包含<code>managed</code>，事实上，大多数是不包含的。对于Core Data类的完整列表，请查看OC中得头文件<code>CoreData/CoreData.h</code></p>
<hr>
<p>当你在创建HitList工程时勾选了Core Data，Xcode会为你自动生成一个名为<code>HitList.xcdatamodeld</code>的数据模型文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-a49e5295c785db82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p11"></p>
<p>点击并打开<code>HitList.xcdatamodeld</code>,你将看到如下强大的数据模型编辑器界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-24a39479a23cc304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p12"></p>
<p>数据模型编辑器界面有很多功能，从现在开始，我们专注于创建单一的Core Data实体。</p>
<p>在左侧点击 <code>Add Entity</code>创建一个新的实体，双击新的实体，将名称更改为<code>Person</code>，如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-5f1c0cf6c859d8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p13"></p>
<p>你可能会疑惑卫生么模型编辑器要使用术语”Enity”，难道你只是简单地定义一个新的类？正如你很快要看到，Core Data有他自己的词汇。下面是你会经常遇到的一些术语的简单整合：</p>
<ul>
<li><code>entity</code>在Core Data中是一个类定义。典型例子是<code>雇员</code>或者<code>公司</code>。在关系型数据库中，一个实体相当于一个表。</li>
<li><code>attribute</code>是附加到特定实体上的一条信息。例如<code>雇员</code>实体能包含雇员的名字，职位和年薪。在数据库中，一个属性相当于一个表中得特定字段。</li>
<li><code>relationship</code>是多个实体之间的链接。在Core Data中，两个实体之间的关系叫做对一关系，多个实体间的关系叫做对多关系。例如，一个经理可以和多个雇员这个就是对多关系，但一个雇员只能有一个经理，这就是对一关系。</li>
</ul>
<hr>
<p><code>Note</code>:你可能已经注意到，实体看起来有点像类，类似的，attribute/relationship看起来有点像properties。他们有什么区别呢？你可以认为Core Data的实体当做一个定义类，把Core Data管理对象当做这个类的实例</p>
<hr>
<p>现在你已经知道attribute是什么了，回到模型编辑器界面在<code>Person</code>中添加一个attribute。选择左手边的<code>Person</code>，点击<code>Attributes</code>下的加号（+）。设置一个新的属性名，取名为<code>name</code>并设置他的type为<code>String</code> ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-670a9b03e266f3f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p14"></p>
<p>在Core Data中，属性有很多种数据类型–其中一种是String。</p>
<h3 id="保存数据到Core-Data"><a href="#保存数据到Core-Data" class="headerlink" title="保存数据到Core Data"></a>保存数据到Core Data</h3><p>在<code>ViewController.swift</code>顶端引入头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Add below &quot;import UIKit&quot;</span><br><span class="line">import CoreData</span><br></pre></td></tr></table></figure>
<p>如果你之前使用过OC的框架，你可能需要在你工程的<code>Build Phases</code>中链接框架，在Swift中，一个简单地<code>import</code>就是你所有需要开始使用Core Data的API要做的事情。</p>
<p>接着，替换之前列表视图的模型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Change [String] to [NSManagedObject]</span><br><span class="line">var people = [NSManagedObject]()</span><br></pre></td></tr></table></figure>
<p>你需要存储的时<code>Person</code>的实体，而不仅仅只是名字，所以你需要将列表视图的数据模型数组重命名为<code>people</code>。它现在拥有的时一个<code>NSManagedObject</code>的实例而不仅仅只是简单地字符串。</p>
<p><code>NSManagedObject</code>表示存储在Core Data中的一个单一对象，你必须使用它来创建，编辑，保存和删除来完成你的Core Data持久化存储。正如你很快就要看到的，<code>NSManagedObject</code>是一个<code>模型接口（shap shifter）</code>。他以实体的形式存在在你的数据模型中，你可以随意使用你定义的attributes和relationship。</p>
<p>因为你改变了列表视图模型，你必须替换掉你之前实现的数据源的方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Replace both UITableViewDataSource methods</span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">    numberOfRowsInSection section: Int) -&gt; Int &#123;</span><br><span class="line">    return people.count</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func tableView(tableView: UITableView,</span><br><span class="line">  cellForRowAtIndexPath</span><br><span class="line">  indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line"> </span><br><span class="line">  let cell =</span><br><span class="line">      tableView.dequeueReusableCellWithIdentifier(&quot;Cell&quot;)</span><br><span class="line">      as UITableViewCell</span><br><span class="line"> </span><br><span class="line">  let person = people[indexPath.row]</span><br><span class="line">  cell.textLabel!.text = person.valueForKey(&quot;name&quot;) as String?</span><br><span class="line"> </span><br><span class="line">  return cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最显著的变化在<code>cellForRowAtIndexPath</code>中，替换模型数组中与cell匹配的对应字符串，你可以使用语cell相对应的<code>NSManagedObject</code>。<br>设置你从<code>NSManagedObject</code>中获取的名字属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.textLabel.text = person.valueForKey(&quot;name&quot;) as String</span><br></pre></td></tr></table></figure>
<p>为什么必须这样做？事实证明，<code>NSManagedObject</code>并不知道你再数据模型重定义的<code>name</code>属性，所以没有办法直接用属性访问它。Core Data 提供读出值的唯一办法只有键-值编码，就是通常所说的KVC。</p>
<hr>
<p><code>Note</code>:如果你是iOS开发的新手，你可能对KVC或者键-值编码不熟悉。</p>
<p>KVC是Cocoa和Cocoa Touch通过间接使用标识对象属性的字符串来访问对象属性的机制。在这种情况下，KVC使<code>NSManagedObject</code>感觉像是字典。</p>
<p>键-值编码可用于继承自<code>NSObject</code>的所有类，包括<code>NSManagedObject</code>。你不能够在没有继承自<code>NSObject</code>的Swift对象中用KVC访问属性</p>
<hr>
<p>接着，替换保存事件<code>addName @IBAction</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let saveAction = UIAlertAction(title: &quot;Save&quot;,</span><br><span class="line"> style: .Default) &#123; (action: UIAlertAction!) -&gt; Void in</span><br><span class="line"> </span><br><span class="line">  let textField = alert.textFields![0] as UITextField</span><br><span class="line">  self.saveName(textField.text)</span><br><span class="line">  self.tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这需要在输入文本到文本框中，然后通过一个方法叫<code>saveName</code>。添加<code>saveName</code>到<code>ViewController.swift</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func saveName(name: String) &#123;</span><br><span class="line">  //1</span><br><span class="line">  let appDelegate =</span><br><span class="line">  UIApplication.sharedApplication().delegate as AppDelegate</span><br><span class="line"> </span><br><span class="line">  let managedContext = appDelegate.managedObjectContext!</span><br><span class="line"> </span><br><span class="line">  //2</span><br><span class="line">  let entity =  NSEntityDescription.entityForName(&quot;Person&quot;,</span><br><span class="line">    inManagedObjectContext:</span><br><span class="line">    managedContext)</span><br><span class="line"> </span><br><span class="line">  let person = NSManagedObject(entity: entity!,</span><br><span class="line">    insertIntoManagedObjectContext:managedContext)</span><br><span class="line"> </span><br><span class="line">  //3</span><br><span class="line">  person.setValue(name, forKey: &quot;name&quot;)</span><br><span class="line"> </span><br><span class="line">  //4</span><br><span class="line">  var error: NSError?</span><br><span class="line">  if !managedContext.save(&amp;error) &#123;</span><br><span class="line">      println(&quot;Could not save \(error), \(error?.userInfo)&quot;)</span><br><span class="line">  &#125;  </span><br><span class="line">  //5</span><br><span class="line">  people.append(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是Core Data的补充，这段代码的作用：</p>
<ol>
<li><p>在你可以保存或者检索你的Core Data存储之前，你需要先获得你的<code>NSManagedObjectContext</code>，你可以把托管对象文本认为是在内存中暂存的管理对象。</p>
<p> 想象一下把储存一个新的管理对象到Core Data看成两个步骤：首先，你插入一个新的管理对象到managed object context；然后，随你乐意提交你的管理对象到managed object context来储存到磁盘上。</p>
<p> Xcode已经生成了一个managed object context 当做新工程模板的一部分——记住，这里仅仅是在你一开始已经选择了<code>Use Core Data</code>选项。这样会默认创建managed object context的property在application delegate当中。你要先得到app delegate的引用，你才访问它。</p>
</li>
<li><p>你创建了一个新的管理对象，然后插入到managed object context中。你可以同时完成<code>NSManagedObject</code>的初始化：<code>init(entity:insertIntoManagedObjectContext:)</code>。</p>
<p> 你可能想知道<code>NSEnityDescription</code>是怎么一回事，回想一下，我们把<code>NSManagedObject</code>称作<code>模型接口（shap shifter）</code>类是因为它表示一个实体。一个实体描述是在运行时从带有<code>NSManagedObject</code>实例的数据模型的实体定义的链接。</p>
</li>
<li><p>随着得到<code>NSManagedObject</code>，你可以通过使用键-值编码设置<code>name</code>属性。你必须拼写KVC的key值(这里指”name”)，而且它必须存在在你的数据模型中，否则你的app可能会在运行时奔溃。</p>
</li>
<li><p>提交你你修改到<code>person</code>然后通过调用managed object context中得<code>save</code>来保存到磁盘上。注意，<code>save</code>的参数是一个指向<code>NSError</code>的指针。如果你的存储操作有任何的错误，你将能够检查出错误，并在必要的时候提醒用户。</p>
</li>
<li><p>恭喜你！你新的管理对象现在已经可以安全的存储在Core data的持久性存储中。插入新的管理对象到<code>people</code>数组中，这样就能在你刷新时，显示在列表视图里。</p>
</li>
</ol>
<p>这里会比一个字符串数组稍稍复杂一些，但并不会难。这里的一些代码-获取managed object context 和实体-能搞在你的<code>init</code>或者<code>viewDidLoad</code>只生成一次，然后重复使用。这里为了简单，在每一个方法你都实现了一次。</p>
<p>编译并运行app，然后添加一些名字：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-89c9ef383e9f99c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p15"></p>
<p>如果你的名字确实被储存在Core Data中，你的HitList app应该能通过持久化测试。双击Home键回到快速app切换页面，上滑HitList app杀死进程。</p>
<p>从页面中点击app并重新启动，稍等片刻，怎么回事？列表视图怎么会是空的？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-2b2e83c863e4b3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p16"></p>
<p>你已经保存到Core Data了，但是重启app后，<code>people</code>数组却依然还是什么都没有！其实那些数据已经坐在那里等你饿了，只是你还没有取得它。</p>
<h3 id="从Core-Data中读取数据"><a href="#从Core-Data中读取数据" class="headerlink" title="从Core Data中读取数据"></a>从Core Data中读取数据</h3><p>为了从你的持久化存储中为managed object context读取数据，你必须把他拿出来。添加如下方法到<code>ViewController.swift</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">override func viewWillAppear(animated: Bool) &#123;</span><br><span class="line">  super.viewWillAppear(animated)</span><br><span class="line"> </span><br><span class="line">  //1</span><br><span class="line">  let appDelegate =</span><br><span class="line">  UIApplication.sharedApplication().delegate as AppDelegate</span><br><span class="line"> </span><br><span class="line">  let managedContext = appDelegate.managedObjectContext!</span><br><span class="line"> </span><br><span class="line">  //2</span><br><span class="line">  let fetchRequest = NSFetchRequest(entityName:&quot;Person&quot;)</span><br><span class="line"> </span><br><span class="line">  //3</span><br><span class="line">  var error: NSError?</span><br><span class="line"> </span><br><span class="line">  let fetchedResults =</span><br><span class="line">    managedContext.executeFetchRequest(fetchRequest,</span><br><span class="line">    error: &amp;error) as [NSManagedObject]?</span><br><span class="line"> </span><br><span class="line">  if let results = fetchedResults &#123;</span><br><span class="line">    people = results</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    println(&quot;Could not fetch \(error), \(error!.userInfo)&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一步一步来解释这些代码都做了什么：</p>
<ol>
<li><p>正如上一章节提到的，在你使用Core Data之前，你需要一个managed object context，读取数据也一样。你需要通过application delegate来获取一个managed object context的引用。</p>
</li>
<li><p>顾名思义，<code>NSFetchRequest</code>是负责从Core Data中读取数据的类。获取请求十分强大且灵活，你可以用请求来读取一组满足特定条件的对象（例如：给我读取所有举着在Wisconsin并且至少在公司工作三年以上的雇员），也可以单个值（例如：给我读取数据库中名字最长的雇员），功能不单单这些。<br> 读取请求有一些提炼返回结果的修饰词。从现在开始，你应该知道<code>NSEntityDescription</code>是其中一个修饰语（这一个是必须的）。<br> 设置过去请求的实体property，或者以<code>init(entityName:)</code>进行初始化，读取特定实体的对象。这就是你再获取所有<code>Person</code>实体要做的事。</p>
</li>
<li><p>处理读取请求给managed object context去做一些繁重的任务。<code>executeFetchRequest(_:error:)</code>返回一个在请求中指定标准的管理对象可选数组。</p>
</li>
</ol>
<hr>
<p><code>Note</code>：如果没有匹配的读取请求条件的对象，该方法返回一个包含空数组的可选值。</p>
<p>如果在读取时发生了错误，则方法返回一个包含0的可选值。如果发生这种情况，你可以检查<code>NSError</code>并采取相应措施。</p>
<hr>
<p>再次编译并运行代码，现在，你应该可以看到你之前添加的名字列表。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-6b59f8bd35e3fbd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p17"></p>
<p>非常棒！他们起死回生了！再添加一些名字到列表里，然后重新启动app来验证保存和读取是否正确运行。只要不是删除app，重置你的模拟器或把你的手机进行出厂恢复，无论如何你的米那个字列表都会出现在列表视图当中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-1e245e33a5a9e4ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p18"></p>
<h3 id="接下来该何去何从？"><a href="#接下来该何去何从？" class="headerlink" title="接下来该何去何从？"></a>接下来该何去何从？</h3><p>在这个教程中，你已经体验到了基本的Core Data概念：数据模型，实体，attributes，管理对象，managed object context和读取请求。<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/10/HitList-Final.zip" target="_blank" rel="external">这里是完整的Hitlist工程</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/30/AppleWatch/" itemprop="url">
                  【译】Apple Watch开发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-30T11:38:37+08:00" content="2014-12-30">
              2014-12-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/30/AppleWatch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/30/AppleWatch/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="本文翻译自Apple官方文档"><a href="#本文翻译自Apple官方文档" class="headerlink" title="本文翻译自Apple官方文档"></a>本文翻译自<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969-CH8-SW1" target="_blank" rel="external">Apple官方文档</a></h4><blockquote>
<p>   <strong>重要声明</strong><br>    这是一个初步的API开发技术文档，苹果公司提供这些信息来帮助你计划采用的技术和使用这里描述的苹果产品的编程接口。这些信息可能随时改变，并根据这个文档来实现软件对应的最新操作系统软件和最新文档进行测试。新版本文档将会提供未来API和技术的测试版本。</p>
</blockquote>
<p>Apple Watch为用户提供了一个私密且不引人注意的方式来访问他们的数据。相较于把iPhone放在在口袋里，用户可以通过看一眼Apple Watch快速地获取重要信息。为Apple Watch开发的App支持以这些简单的交互以最直接的方式只提供最相关的信息。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/Art/watch_apps_2x.png" alt="p1"></p>
<p>Apple Watch需要iPhone运行一个第三方App。建立一个第三方App需要两个独立的可执行程序：一个在Apple Watch上运行的Watch App和一个在用户iPhone上运行的WatchKit扩展。Watch App只包含与你的App用户界面上有关的故事板和资源文件。WatchKit扩展包含用于管理Watch App用户界面和响应用户交互。随着这两个可执行文件，你可以在Apple Watch上支持不同类型的用户交互：</p>
<ul>
<li>你的Watch App包含你的App的完整用户界面。用户从主屏幕启动你的App，然后使用App来查看或者处理数据。</li>
<li>glance是你用来显示你App最及时和相关的信息的一个可选只读接口。不是所有的App都需要看一眼，但这是一种为用户提供了方便访问你App数据的方式。</li>
<li>自定义通知接口让你能够改变显示最近收到的本地和远程通知的默认界面，并添加自定义图形，内容和格式。自定义通知接口是可选的。</li>
</ul>
<p>一个Watch App需要Apple Watch上的所有交互。因为一个Watch App扩展现有iOS App的行为，所以一个Watch App和 WatchKit扩展绑定在一起，并且在你的iOS App程序包内安装。在安装过程中，如果已经配对了Apple Watch，系统会提示用户安装Watch App。</p>
<h3 id="创建Watch-App"><a href="#创建Watch-App" class="headerlink" title="创建Watch App"></a>创建Watch App</h3><p>一个Watch App是和你Apple Watch上的内容交互的基础。Watch App是从主屏幕访问的，且通常提供包含iOS App的一部分功能。Watch App的目的是为了让用户快速且更加深入的访问app相关数据。</p>
<p>Watch App与iPhone上运行的相应的WatchKit 扩展协同工作。Watch App不包含自定义代码，只用于存储与用户界面有关的故事板和资源文件。该WatchKit扩展是整个操作的大脑，它包含你管理内容，响应用户交互，更新界面的业务逻辑和代码。因为它运行在用户手机中，WatchKit扩展可以很容易地与你的iOS应用程序协作，从而收集定位更新或者执行其他长时间运行的任务。</p>
<p>要开始创建Watch App，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/CreatingtheUserInterface.html#//apple_ref/doc/uid/TP40014969-CH4-SW1" target="_blank" rel="external">App Essentials</a>。</p>
<h3 id="创建快速浏览界面（Glance-Interface）"><a href="#创建快速浏览界面（Glance-Interface）" class="headerlink" title="创建快速浏览界面（Glance Interface）"></a>创建快速浏览界面（Glance Interface）</h3><p>快速浏览是展现用户当前最需要的重要信息的集中界面。快速浏览恰如其名，因为它的目的是快速的看着。快速浏览不需要滚动，所以整个界面必须符合单一屏幕。快速浏览是只读的，不能包含按钮，开关或其他交互控制。点击快速浏览就能启动你关注的Watch App。</p>
<p>用来管理快速浏览的代码写在你的Watch App扩展中。用来管理你快速浏览界面的类与你用来管理Watch App的类相同。尽管他们的类和基本行为是相同的，但快速浏览更容易实现，因为它不需要向用户进行交互。</p>
<p>要开始创建快速浏览界面，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/ImplementingaGlance.html#//apple_ref/doc/uid/TP40014969-CH5-SW1" target="_blank" rel="external">Glance Essentials</a>。</p>
<h3 id="自定义通知的显示"><a href="#自定义通知的显示" class="headerlink" title="自定义通知的显示"></a>自定义通知的显示</h3><p>Apple Watch为与其配对的iPhone显示本地及远程的通知。最初，Apple Watch用来显示来电通知，当移动用户表示希望看到更多的信息时，最小界面变化为更详细的界面来显示通知的内容。App可以提供详细接口的版本及自定义图形，或者整理出与系统提供的默认接口不同的通知数据。</p>
<p>Apple Watch支持在iOS8中引入交互式通知。交互式通知是一种添加按钮到通知使其能够响应用户与之交互的方式。例如，进入日历可能包括一个按钮使你接受或者拒绝会议邀请。当你的iOS App注册支持交互式通知后，Apple Watch自动为自定义及默认通知界面添加相应的按钮。你所需要做的只是处理用户在你WatchKit扩展上选择操作。</p>
<p>要开始创建一个自定义通知界面，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/BasicSupport.html#//apple_ref/doc/uid/TP40014969-CH18-SW1" target="_blank" rel="external">Notification Essentials</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/08/OCRuntime/" itemprop="url">
                  【译】Objective-C Runtime
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-08T11:36:04+08:00" content="2014-12-08">
              2014-12-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/08/OCRuntime/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/08/OCRuntime/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容如下：</p>
<ul>
<li>引言</li>
<li>简介</li>
<li>与 Runtime 交互</li>
<li>Rumtime 术语</li>
<li>消息</li>
<li>动态方法解析</li>
<li>消息转发</li>
<li>健壮的实例变量（Non Fragile ivars）</li>
<li>Objective-C Associated Objects</li>
<li>Method Swizzling</li>
<li>总结</li>
</ul>
<h4 id="本文为转载，出处链接后续补上。。"><a href="#本文为转载，出处链接后续补上。。" class="headerlink" title="本文为转载，出处链接后续补上。。"></a>本文为转载，出处链接后续补上。。</h4><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><hr>
<p>曾经觉得Objc特变方便上手，面对着Cocoa中大量API，只知道简单地查看文档和调用。还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单地方法调用，而无视了“发送消息”这句话的深刻含义。于是<code>[receiver message]</code>会被编译器转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_mesgSend(receiver,selector)</span><br></pre></td></tr></table></figure>
<p>如果消息含有参数，则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_mesgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完奔溃掉。</p>
<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性， 这些深层次的只是虽然平时写代码用的少一些，但是却是每个Objc程序员需要了解的。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr>
<p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译链接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统(runtime system)来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p>
<p>Runtime 其实有两个版本:”modern”和”legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中得(早期) Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版本就不需要。</p>
<p>Runtime 基本使用C和汇编写的，可见苹果为了动态系统的高效而做出的努力。你可以在<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="external">这里</a>下载到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>
<h3 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a>与Runtime交互</h3><hr>
<p>Objc 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的<code>NSObject</code>类定义的方法，通过对runtime函数直接调用。</p>
<h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行，runtime系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中得类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中得<code>id</code>和<code>SEL</code>都是啥    ）</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活都交给幕后小弟去干。</p>
<p>有的<code>NSObject</code>中得方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass:</code> 和 <code>isMemberOfClass:</code> 则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
<h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样地功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a href="">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>
<h3 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a>Runtime术语</h3><hr>
<p>还记得引言中得<code>objc_msgSend:</code>方法吧，它的真身是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...);</span><br></pre></td></tr></table></figure>
<p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是Selector类）。<code>selector</code>是方法选择器，可以理解为区分方法的ID，而这个ID的数据结构是<code>SEL</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>其实它就是个映射到方法的C字符串，你可以用Objc编译器命令<code>@selector()</code>或者 Runtime 系统的<code>sel_registerName</code>函数来获得一个<code>SEL</code>类型的方法选择器。</p>
<p>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型（<code>NSNumber</code>一堆抽象工厂方法拿走不谢），Cocoa中有好多长长的方法哦。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struc objc_object *id;</span><br></pre></td></tr></table></figure>
<p>那<code>objc_object</code>又是啥呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123; Class isa;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>结构体包含一个<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>而<code>objc_class</code>就是我们魔道的那个瓜，里面的东西多着呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="未完待续。。。）"><a href="#未完待续。。。）" class="headerlink" title="(未完待续。。。）"></a>(未完待续。。。）</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/08/GCDP1/" itemprop="url">
                  【译】深入理解GCD:Part1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-08T11:32:20+08:00" content="2014-12-08">
              2014-12-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/08/GCDP1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/08/GCDP1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然 GCD 已经出现过一段时间了，但不是每个人都明了其主要内容。这是可以理解的；并发一直很棘手，而 GCD 是基于 C 的 API ，它们就像一组尖锐的棱角戳进 Objective-C 的平滑世界。我们将分两个部分的教程来深入学习 GCD 。</p>
<p>在这两部分的系列中，第一个部分的将解释 GCD 是做什么的，并从许多基本的 GCD 函数中找出几个来展示。在<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md" target="_blank" rel="external">第二部分</a>，你将学到几个 GCD 提供的高级函数。</p>
<hr>
<p>本文翻译自 <a href="http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">http://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1</a></p>
<hr>
<h3 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h3><hr>
<p>GCD是<code>libdispatch</code> 的市场名称，而libdispatch作为Apple的一个库，为并发代码在多核硬件（跑iOS或OSX）上执行提供有力支持。它具有以下优点：</p>
<ul>
<li>GCD能通过推迟昂贵计算任务并在后台运行他们来改善你的应用的响应性能</li>
<li>GCD提供一个易于使用的并发模型而不仅仅是锁和线程，以帮助我们避开并发陷进。</li>
<li>GCD具有常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。</li>
</ul>
<p>本教程假设你对Block合GCD有基础了解。如果你对GCD完全陌生，先看看<a href="http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial" target="_blank" rel="external">iOS上德多线程和GCD入门教程</a> 学习其要领。</p>
<h3 id="GCD术语"><a href="#GCD术语" class="headerlink" title="GCD术语"></a>GCD术语</h3><hr>
<p>要理解GCD，你要熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始GCD之前先简要地回顾以下它们。</p>
<h4 id="Serial-vs-Concurrent-串行-vs-并行"><a href="#Serial-vs-Concurrent-串行-vs-并行" class="headerlink" title="Serial vs. Concurrent 串行 vs. 并行"></a>Serial vs. Concurrent 串行 vs. 并行</h4><p>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</p>
<p>虽然这些术语被广泛使用，本教程中你可以将任务设定为一个Objective-C的Block。不明白什么是Block?看看<a href="http://www.raywenderlich.com/9328/creating-a-diner-app-using-blocks-part-1" target="_blank" rel="external">iOS5教程中的如何使用Block</a>。实际上，你也可以在GCD上使用函数指针，但在大多数场景中，这实际上更难于使用。Block就是更加容易些！</p>
<h4 id="Synchonous-vs-Asynchronous-同步-vs-异步"><a href="#Synchonous-vs-Asynchronous-同步-vs-异步" class="headerlink" title="Synchonous vs. Asynchronous 同步 vs. 异步"></a>Synchonous vs. Asynchronous 同步 vs. 异步</h4><p>在GCD中，这些术语描述当一个函数相对于另外一个任务完成，此任务是该函数要求GCD执行的。一个同步函数只在完成了它预定的任务后才返回。</p>
<p>一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</p>
<p>注意–当你读到同步函数“阻塞(Block)”当前线程，或函数是一个“阻塞”函数或阻塞操作时，不要被搞糊涂了！动词“阻塞”描述了函数如何影响它所在的线程而与名词“代码块(Block)”没有关系。代码块描述了用Objective-C编写的一个匿名函数，它能定义一个任务并被提交到GCD。</p>
<p>译者注：中文不会有这个问题，“阻塞”和“代码块”是两个词。</p>
<h4 id="Critical-Section-临界区"><a href="#Critical-Section-临界区" class="headerlink" title="Critical Section 临界区"></a>Critical Section 临界区</h4><p>就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很肯能会变质（译者注：它的值不再可信）。</p>
<h4 id="Race-Condition-竞态条件"><a href="#Race-Condition-竞态条件" class="headerlink" title="Race Condition 竞态条件"></a>Race Condition 竞态条件</h4><p>这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。</p>
<h4 id="Deadlock-死锁"><a href="#Deadlock-死锁" class="headerlink" title="Deadlock 死锁"></a>Deadlock 死锁</h4><p>两个（有时更多）东西–在大多数情况下,是线程–所谓的死锁是指他们都卡住了，并等待对方完成或执行其他操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>
<h4 id="Thread-Safe-线程安全"><a href="#Thread-Safe-线程安全" class="headerlink" title="Thread Safe 线程安全"></a>Thread Safe 线程安全</h4><p>线程安全的代码能在多线程或并发任务中被安全调用，而不会导致任何问题（数据算坏，奔溃，等）。线程不安全的代码在摸个时刻只能在一个上下文中运行。一个线程安全代码的例子是<code>NSDictionary</code>。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，<code>NSMutableDictionary</code>就不是线程安全的，应该保证一次只能有一个线程访问它。</p>
<h4 id="Context-Switch-上下文切换"><a href="#Context-Switch-上下文切换" class="headerlink" title="Context Switch 上下文切换"></a>Context Switch 上下文切换</h4><p>一个上下文切换指当你在当个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>
<h4 id="Concurrency-vs-Parallelism-并发与并行"><a href="#Concurrency-vs-Parallelism-并发与并行" class="headerlink" title="Concurrency vs. Parallelism 并发与并行"></a>Concurrency vs. Parallelism 并发与并行</h4><p>并发和并行通常被一起提到，所以值得花些时间解释他们之间的区别。</p>
<p>并发代码的不同部分可以“同步”执行。然而，改怎样发生或是否发生都决定于多系统。多核设备通过并行来同事执行多个线程；然而，为了使单核设备也能实现这一点，他们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生得足够快以致给我们并发执行的错觉，如下图所示：<br><img src="https://camo.githubusercontent.com/55145c5a8cf3d6f840e7267acd550869f92becfe/687474703a2f2f63646e312e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f436f6e63757272656e63795f76735f506172616c6c656c69736d2e706e67" alt="p1"></p>
<p>虽然你可以编写代码在GCD下并发执行，但GCD会决定有多少并行的需求。并行要求并发，但并发并不能保证并行。</p>
<p>更深入的观点是并发实际上是关于构造。当你在脑海中用GCD编写代码，你组织你的代码来暴露同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看<a href="http://vimeo.com/49718712" target="_blank" rel="external">这个由Rob Pike做的精彩的讲座</a></p>
<h4 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues 队列"></a>Queues 队列</h4><p>GCD提供有<code>dispatch queues</code>来处理代码块，这些队列管理提供给GCD的任务并用FIFO顺序执行这些任务。这就保证了第一个被添加到队列里地任务回事队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此知道队列的终点。</p>
<p>所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行地访问他们。当你了解了调度队列如何为自己代码的不同部分提供线程安全后，GCD的优点就是显而易见的。关于这一点的关键是选择正确类型的调度队列和正确地调度函数来提交你的工作。</p>
<p>在本节你会看到两种调度队列，都是由GCD提供的，然后看一些描述如何用调度函数添加工作到队列的例子。</p>
<h4 id="Serial-Queues-串行队列"><a href="#Serial-Queues-串行队列" class="headerlink" title="Serial Queues 串行队列"></a>Serial Queues 串行队列</h4><p>串行队列中得任务一次执行一个，每个任务只在前一个任务完成时才开始。而且，你不知道在一个Block结束和下一个开始之间的时间长度，如下图所示：<br><img src="https://camo.githubusercontent.com/e337c0cb657dde8d7eeb5468a1724c751cedb484/687474703a2f2f63646e342e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f53657269616c2d51756575652d343830783237322e706e67" alt="p2"></p>
<p>这些任务执行的时机受到GCD的控制；唯一能确保的事情是GCD一次只能执行一个任务，并且按照我们添加到队列的顺序来执行。</p>
<p>由于在串行队列中不会有两个任务并发运行，因此不会出新同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区安全问题了。</p>
<h4 id="Concurrent-Queues-并发队列"><a href="#Concurrent-Queues-并发队列" class="headerlink" title="Concurrent Queues 并发队列"></a>Concurrent Queues 并发队列</h4><p>在并发队列中得任务能得到的保证是它们会按照被添加的顺序开始执行，但这既是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少Block在运行。再说一遍，这完全取决于GCD。</p>
<p>下图展示了一个示例任务执行计划，GCD管理者四个并发任务：<br><img src="https://camo.githubusercontent.com/607942d30c4701a1a721781264fa815f100668a5/687474703a2f2f63646e332e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f436f6e63757272656e742d51756575652d343830783237322e706e67" alt="p3"></p>
<p>注意Block1，2和3都立马开始运行，一个接一个。在Block0开始后，Block1等待了好一会儿才开始。同样，Block3在Block2之后才开始，但它先于Block2完成。</p>
<p>何时开始一个Block完全取决于GCD。如果一个Block的执行时间与另一个重叠，也是由GCD来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的Block。</p>
<p>有趣的是，GCD提供给你至少五个特定的队列，可根据队列类型选择使用。</p>
<h4 id="Queue-Types-队列类型"><a href="#Queue-Types-队列类型" class="headerlink" title="Queue Types 队列类型"></a>Queue Types 队列类型</h4><p>首先，系统提供给你一个叫做<code>主队列（main queue）</code>的特殊队列。和其他串行队列一样，这个队列中得任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新UI的线程。这个队列就是用于发生消息给<code>UIView</code>或发送通知的。系统同时提供给你好几个并发队列。它们叫做<code>全局调度队列(Global Dispatch Queues)</code>。目前的四个全局队列有着不同的优先级：<code>background</code>、<code>low</code>、<code>default</code>以及<code>high</code>。要知道，Apple的API也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。</p>
<p>最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有五个队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。</p>
<p>以上是调度队列的大框架！</p>
<p>GCD的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的例子，我们沿途会提供一些一般性的建议。</p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><hr>
<p>既然本教程的目标是优化且安全的使用GCD调用来自不同线程的代码，那么你将从一个近乎完成的叫做<code>googlyPuff</code>的项目入手。</p>
<p>GooglyPuff是一个没有优化，线程不安全的应用，它使用Core Image 的人脸检测API来覆盖一对曲棍球眼睛到被检测到得人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的URL从互联网下载。</p>
<p><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_Start_1.zip" target="_blank" rel="external">点击此处下载项目</a></p>
<p>完成项目下载之后，将其解压到某个方便的目录，再用Xcode打开它并编译运行。这个应用看起来如下图所示：<br><img src="https://camo.githubusercontent.com/d5493d544baf1f04eca67579f0e6e2c2ce75d599/687474703a2f2f63646e332e72617977656e6465726c6963682e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031342f30312f576f726b666c6f77312e706e67" alt="p4"></p>
<p>注意当你选择<code>Le Internet</code>选项下载图片时，一个<code>UIAlertView</code>过早地弹出。你将在本系列教程的第二部分修复这个问题。</p>
<p>这个项目中有四个有趣的类：</p>
<ul>
<li>PhotoCollectionViewController:他是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。</li>
<li>PhotoDetailViewController:它执行添加曲棍球眼睛到图像上德逻辑，并用一个UIScrollView来显示结果图片。</li>
<li>Photo:这是一个类，它根据一个<code>NSURL</code>的实例或一个<code>ALAsset</code>的实例来实例化照片。这个类提供一个图像、缩略图以及从URL下载的状态。</li>
<li>PhotoManager:它管理所有<code>Photo</code>的实例。</li>
</ul>
<h3 id="用dispatch-async处理后台任务"><a href="#用dispatch-async处理后台任务" class="headerlink" title="用dispatch_async处理后台任务"></a>用dispatch_async处理后台任务</h3><hr>
<p>回到应用并从你的相机胶卷添加一些照片或使用<code>Le Internet</code>选项下载一些。</p>
<p>注意在按下<code>PhotoCollectionViewController</code>中得一个<code>UICollectionViewCell</code>到生成一个新的<code>PhotoDetailViewController</code>之间花了多久时间；你会注意到一个明显的滞后，特变是在比较慢得设备上查看很大的图。</p>
<p>在重载<code>UIViewController的viewDidLoad</code>时容易加入太多杂波(too much clutter)，这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果他们不是绝对必须要运行在加载时间里。</p>
<p>这听起来像是<code>dispatch_async</code>能做的事情！</p>
<p>打开<code>PhotoDetailViewController</code>并用下面的实现替换<code>viewDidLoad</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;   </span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSAssert(_image, @&quot;Image not set; required to use view controller&quot;);</span><br><span class="line">    self.photoImageView.image = _image;</span><br><span class="line"></span><br><span class="line">    //Resize if neccessary to ensure it&apos;s not pixelated</span><br><span class="line">    if (_image.size.height &lt;= self.photoImageView.bounds.size.height &amp;&amp;</span><br><span class="line">        _image.size.width &lt;= self.photoImageView.bounds.size.width) &#123;</span><br><span class="line">        [self.photoImageView setContentMode:UIViewContentModeCenter];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1</span><br><span class="line">        UIImage *overlayImage = [self faceOverlayImageFromImage:_image];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; // 2</span><br><span class="line">            [self fadeInNewImage:overlayImage]; // 3</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="(未完待续。。。)"></a>(未完待续。。。)</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/08/Xcodeskill/" itemprop="url">
                  【译】提高你的Xcode开发效率
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-12-08T11:28:22+08:00" content="2014-12-08">
              2014-12-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2014/12/08/Xcodeskill/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/08/Xcodeskill/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你在全明星好莱坞中看到过程序员入侵主机，手指在键盘上飞速的敲击，而终端的屏幕在飞舞。如果你曾经想成为这样的程序员，那你来对地方了！</p>
<p>这个教程将告诉你在<code>Xcode</code>中如何更像一名程序员。在你学习了本教程之后，你会觉得自己变得更酷（提高了Xcode的编程效率），甚至可以获得拯救世界免于毁灭的威力。你可以按你喜欢的任何方式称呼它–魔法，疯狂技能，纯粹走运或者黑客入侵，这都没有任何问题。</p>
<h4 id="从这里开始"><a href="#从这里开始" class="headerlink" title="从这里开始"></a>从这里开始</h4><p>由于我们的目标是为了变得更酷，以下教程将让指引我们朝着酷点需要做到哪些：</p>
<ul>
<li><p>快速执行任务</p>
</li>
<li><p>更加精准和准确</p>
</li>
<li><p>拥有整洁美观的代码</p>
</li>
</ul>
<p>为了获得额外的忍者点数，你可以试着在不用鼠标和触摸板的情况下完成任务。是的，也就是说在不使用鼠标和触摸板的情况下在<code>Xcode</code>中实现<a href="http://www.raywenderlich.com/25736/how-to-make-a-simple-iphone-game-with-cocos2d-2-x-tutorial" target="_blank" rel="external"><code>pewpew</code></a>这个程序。</p>
<p>你将开始学习到一些<code>Xcode</code>中有用的功能，然后，你将继续在和<a href="http://www.raywenderlich.com/49311/advanced-table-view-animations-tutorial-drop-in-cards" target="_blank" rel="external"><code>这个教程</code></a>相似的<code>CardTilt</code>工程中，通过修复bug做一些练习。最后你将能够如同像素般精确地梳理你的代码。</p>
<p>请记住本教程并不是教你最终的应用应该怎么写，而是告诉你如何利用<code>Xcode</code>的优势更加高效地写出比原来更优雅地代码。</p>
<p>本教程假定你对编程有基本的了解，并着重于提高您作为一个程序员的工作效率。每个人得写代码习惯是不同的，因此，本教程并不是强迫你一定要按照这样的风格写代码。</p>
<p>自始至终，你将替换某些代码。当你坚持下来，你只需要专注于提炼和构筑你现在的开发风格，并试着不要因为一些差异就放弃。</p>
<p>注意：如果你对自己Xcode的使用还不是很有信心，你可以先阅读这些文章：<a href="http://www.raywenderlich.com/38557/learn-to-code-ios-apps-1-welcome-to-programming" target="_blank" rel="external">Learn to Code iOS Apps 1: Welcome to Programming</a>, <a href="http://www.raywenderlich.com/1797/ios-tutorial-how-to-create-a-simple-iphone-app-part-1" target="_blank" rel="external">iOS Tutorial: How To Create A Simple iPhone App</a></p>
<p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/CardTilt-starter.zip" target="_blank" rel="external">CardTilt-starter</a>并准备开始编程！</p>
<h4 id="Xcode每日任务"><a href="#Xcode每日任务" class="headerlink" title="Xcode每日任务"></a>Xcode每日任务</h4><p>在大多数工程中有一些任务是你在Xcode中需要定期执行的。本章节将仔细介绍这些任务，并谈论一些潇洒运用的技巧。随着你的进步，你将掌握这些技巧并发现一些新的方式去使用他们。这些技巧将成为你编写代码的工具一绝，就像忍者星或者烟雾弹一样。</p>
<p>在Xcode中打开<code>CardTilt</code>，先不要立刻就开始编写代码。首先，先花一些时间来熟悉你看到的下面这张Xcode工作空间的窗口的图片。</p>
<p>本教程的这些标签将标注工作空间的个别部分。如果你的设置窗口看起来不是这样，不用担心，下面的热键章节将教会你如何轻松的显示并且避免不同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-756b440c6c9c6361.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p1"></p>
<p>下面是一些工作区视图的简要介绍：</p>
<ul>
<li><p><code>Toolbar</code>:该区域可以选择你的方案和目的，运行你的程序，以及通用接口布局之间惊醒切换。</p>
</li>
<li><p><code>Navigation Area</code>: 这里概括你的项目，符号，错误和导航。</p>
</li>
<li><p><code>Editing Area</code>:这里是你所有魔法发生区域。包括顶端视图的附件。</p>
</li>
<li><p><code>Utility Area</code>:包括检测和库文件。</p>
</li>
<li><p><code>Debugging Area</code>:包括编译结果和变量监测。</p>
</li>
</ul>
<p>在项目工作中，你每天都要和这些视图互动，所有这些视图在Xode中都是必不可少的。通常你也不需要一次把他们都看完，下个章节我们将教你如何快速通过热键来配置你的工作空间。</p>
<h4 id="热键"><a href="#热键" class="headerlink" title="热键"></a>热键</h4><p>在这个超酷的教程中，你首先将学会如何掌握这些热键，最最有用的热键是非常容易通过一些模式记住的。</p>
<p>准备好深深地敬畏如下的热键。</p>
<p>首先需要知道那些常见热键各个部分的关系。</p>
<p>以下是最常见的一些热键：</p>
<ul>
<li><p>Command (⌘):用来导航，主要用来控制导航区域。</p>
</li>
<li><p>Alt (⎇): 控制右边的辅助编辑器或者其他实用的编辑器。</p>
</li>
<li><p>Control:跳转栏和顶部编辑栏区域的交互。</p>
</li>
</ul>
<p>第二部分需要记住的时数字键以及标签切换关系。数字键和上述修饰键的组合将使你在标签之间快速地切换。</p>
<p>一般来说，数字对应标签的索引（从1开始），而0一般是隐藏或者显示该区域。这样足够直观不？</p>
<p>最常见的组合有：</p>
<ul>
<li><p>Command 1~8 用来跳转导航栏，Command 0 用来关闭导航区域。</p>
</li>
<li><p>Command Alt 1~6 用来跳转栏工具栏，Command Alt 0 用来关闭工具栏。</p>
</li>
<li><p>Control Command Alt 1~4 用来跳转库文件。</p>
</li>
<li><p>Control 1~6 用来展开跳转栏标签。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/126473-77a347da733cc901.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="p2"></p>
<p>最后一个，也是最简单的模式是回车键。当和Command键一起使用时，能让你在编辑栏之间切换。</p>
<ul>
<li><p>Command + Enter: 显示标准当窗口编辑视图。</p>
</li>
<li><p>Command Alt Enter: 你应该能猜到，事实上，它用来打开助理编辑器。</p>
</li>
<li><p>Command Alt Shift Enter: 打开版本控制编辑器</p>
</li>
</ul>
<p>最后，但并不是最不重要，打开或者关闭调试区域用Command + Shift + Y。要记住这样只需要问，”Y is my code not working?”</p>
<p>如果你忘记了，你可以在Xcode中的Navigate菜单中找到这些热键。</p>
<p>看完这个章节，你就可以随时用你的键盘在Xcode中飞舞了。</p>
<p>####（未完待续）。。。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars1.githubusercontent.com/u/6028247?v=3&s=460"
               alt="MarkLin" />
          <p class="site-author-name" itemprop="name">MarkLin</p>
          <p class="site-description motion-element" itemprop="description">来自⎡凹凸实验室⎦iOSer的Blog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/marklin2012" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MarkLin</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"devmarklinblog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  
  


</body>
</html>
